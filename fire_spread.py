# -*- coding: utf-8 -*-
"""Fire_Spread_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yGbYu2mZlQ2D1D4nsyVNx-Qo1uqWnuYp
"""

import pandas as pd
import numpy as np
from google.colab import files

final = files.upload()

data = pd.read_csv('./final_eng.csv')

data.head(10)

# Preprocess data
# Convert date to datetime and extract cyclical features
data['Date'] = pd.to_datetime(data['Date'], dayfirst=True)
data['cos_hour'] = np.array(np.cos(data['Date'].dt.hour * ((360/24)*(np.pi/180.0))))
data['sin_hour'] = np.array(np.sin(data['Date'].dt.hour * ((360/24)*(np.pi/180.0))))
data['cos_month'] = np.array(np.cos((data['Date'].dt.month) * ((360/12)*(np.pi/180.0))))
data['sin_month'] = np.array(np.sin((data['Date'].dt.month) * ((360/12)*(np.pi/180.0))))
data['cos_dir_wind'] = np.array(np.cos(data['Wind Direction '] * (np.pi / 18.0)))
data['sin_dir_wind'] = np.array(np.sin(data['Wind Direction '] * (np.pi / 18.0)))

# Drop unnecessary columns
data.drop(columns=['Date', 'Wind Direction '], inplace=True)

data = data.apply(pd.to_numeric)

data = data.dropna()

data

from sklearn.preprocessing import StandardScaler

train_size = 18000
data = pd.DataFrame(data)
sc_X = StandardScaler()
sc_X.fit(data.iloc[:train_size])
data = sc_X.transform(data)
data = pd.DataFrame(data)
sc_y = StandardScaler()
sc_y.fit(data.iloc[:train_size,[3,-2,-1]])
data.iloc[:,[3,-2,-1]] = sc_y.transform(data.iloc[:,[3,-2,-1]])
data = pd.DataFrame(data)

data.iloc[:,[3,-2,-1]]

past_timesteps = 5
futur_timesteps = 1

X = [np.array(data.iloc[index:index+past_timesteps,:]) for index in range(len(data)-past_timesteps-futur_timesteps)]
y = [np.array(data.iloc[index:index+futur_timesteps,[3,-2,-1]]) for index in range(past_timesteps,len(data)-futur_timesteps)]

X = np.array(X)
y = np.array(y)

X_train = X[:train_size,:,:]
X_test = X[train_size:,:,:]
y_train = y[:train_size,:,:]
y_test = y[train_size:,:,:]

input_size = len(data.columns)
output_size = 3
nb_epochs = 30
batch_size = 128
use_dropout = False
lstm_recurrent_dropout = 0
lstm_dropout = 0
fc_dropout = 0.2
hidden_size_lstm = 128*2
hidden_size_fc1 = 128

from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Reshape

# Create the network
model = Sequential()
model.add(LSTM(hidden_size_lstm, input_shape=(past_timesteps,input_size) , return_sequences=True, recurrent_dropout=lstm_recurrent_dropout, dropout=lstm_dropout))
#model.add(LSTM(hidden_size_lstm return_sequences=True, recurrent_dropout=lstm_recurrent_dropout, dropout=lstm_dropout))
model.add(Flatten())
if use_dropout:model.add(Dropout(fc_dropout))
model.add(Dense(units = hidden_size_fc1, activation = 'relu'))
if use_dropout: model.add(Dropout(fc_dropout))
model.add(Dense(units = output_size*futur_timesteps, activation = 'linear'))
model.add(Reshape((futur_timesteps, output_size)))

# Compile the network
model.compile(loss='mean_squared_error', optimizer='adam')

model.fit(X_train,y_train, epochs=nb_epochs, batch_size=batch_size)

y_pred = model.predict(X_test)

cos_first_hour = sc_y.inverse_transform(y_pred[:,0,:])[:,-2]
sin_first_hour = sc_y.inverse_transform(y_pred[:,0,:])[:,-1]
for i in range(len(cos_first_hour)):
    mul = 1 if sin_first_hour[i] >= 0 else -1
    cos_first_hour[i] = mul*np.arccos(max(min(1,cos_first_hour[i]),-1))

first_hour = cos_first_hour*180/np.pi
speed_ar= abs(sc_y.inverse_transform(y_test[:,0,:])[:,0])

from sklearn.metrics import mean_squared_error, mean_absolute_error, roc_auc_score
import matplotlib.pyplot as plt
# Calculate MSE and MAE
mse = mean_squared_error(y_test.reshape(-1), y_pred.reshape(-1))
mae = mean_absolute_error(y_test.reshape(-1), y_pred.reshape(-1))

print(f'Mean Squared Error: {mse}')
print(f'Mean Absolute Error: {mae}')

import numpy as np
from sklearn.metrics import roc_curve, auc
from sklearn.preprocessing import label_binarize
import matplotlib.pyplot as plt

# Example threshold value for binary classification; adjust based on your data
threshold = 0.5

# Generate binary_true from your actual data
# Assuming y_test[:,0,0] represents the condition and you've set a threshold for classification
binary_true = (y_test[:,0,0] > threshold).astype(int)

# Generate binary_pred from your model's predictions
# Let's assume y_pred[:,0,0] after inverse transformation represents a similar condition as binary_true
# Apply inverse transformation if your data was scaled/normalized
binary_pred_prob = (y_pred[:,0,0] > threshold).astype(int)

# Calculate ROC AUC
fpr, tpr, _ = roc_curve(binary_true, binary_pred_prob)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

import random
import imageio
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import display, clear_output

mask_file = files.upload()
landscape_file = files.upload()

# Load mask and landscape
mask = ((imageio.imread('./mask360.jpg')[:,:,0]) / 255) > 0.9
landscape_img = imageio.imread('./landscape.jpg')

wind_filter = np.array([[0.3,1.0,0.3], [0.15,0,0.15], [0.1,0.1,0.1]])

def prob_fire(surrounding, wind_filter, mask_value):
    prob = int(mask_value) * np.sum((surrounding == 1) * wind_filter) / 2
    return int(prob > random.random() and mask_value)

# Function to update and display the fire propagation
def update(forest_state, mask):
    new_forest_state = np.copy(forest_state)
    for i in range(1, len(forest_state) - 1):
        for j in range(1, len(forest_state[0]) - 1):
            if forest_state[i,j] != 1:
                new_forest_state[i,j] = min(1, prob_fire(forest_state[i-1:i+2, j-1:j+2], wind_filter, mask[i,j]))
    return new_forest_state

# Initialize the forest state
forest_state = np.zeros(mask.shape)

# Starting a fire manually at the center for demonstration
forest_state[180,180] = 1

# Function to plot the current state
def plot_forest(forest_state):
    plt.figure(figsize=(10, 10))
    plt.imshow(landscape_img)
    plt.imshow(np.ma.masked_where(forest_state == 0, forest_state), cmap='Reds', alpha=0.5)
    plt.axis('off')
    display(plt.gcf())
    clear_output(wait=True)
    plt.close()

# Simulate fire propagation
for _ in range(100): # Number of simulation steps
    forest_state = update(forest_state, mask)
    plot_forest(forest_state)